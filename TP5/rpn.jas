// 
//   rpn.jas
//
//   Author
//	Ruth AYIVI <ruth.ayivi@etudiant.univ-rennes1.fr>
//	Ezan TAHI <ezan.tahi@etudiant.univ-rennes1.fr>
//
//   Description
//	Ce programme lit des caractères tapés dans la "input console" en notation
//	polonaise inversée et affiche le résultat du calcul dans la "output console"
//

.main

BEGIN:		IN					// Cette instruction lit un caractère et le met sur la pile
			DUP					// Duplique l'élément au sommet de la pile (pour la comparaison)
			BIPUSH 0x43				// Empile 0x43 (Code ASCII de l'opérateur +) pour le comparer avec le caractère lu
			IF_ICMPEQ ADD			// Si le caractère lu est '+' on branche vers ADD (pour l'addition)
			DUP					// Sinon, on duplique à nouveau le caractère lu (Car le dernier duplicata a été dépilé pour la comparaison précédente)
			BIPUSH 0x45				// Empile 0x45 (Code ASCII de l'opérateur -) pour le comparer avec le caractère lu
			IF_ICMPEQ SUB			// Si le caractère lu est '-' on branche vers SUB (pour la soustraction)
			DUP					// Sinon, on duplique à nouveau le caractère lu
			BIPUSH 0x10				// Empile 0x10 (Code ASCII de l'opérateur FIN DE LIGNE) pour le comparer avec le caractère lu
			IF_ICMPEQ OUTPUT_RESULT		// Si le caractère lu est FIN DE LIGNE, on branche vers OUTPUT_RESULT (pour afficher le résultat)
			DUP					// Sinon, on duplique à nouveau le caractère lu
			BIPUSH 0x48				// Empile 0x48 (Code ASCII du caractère '0') pour le comparer avec le caractère lu
			IFLT REMOVE_IN			// Si le caractère lu a un code ASCII inférieur à celui de '0', on branche vers REMOVE_IN (pour retirer le caractère saisi)
			DUP					// Sinon, on duplique à nouveau le caractère lu
			BIPUSH 0x58				// Empile 0x58 (Code ASCII du caractère qui suit '9') pour le comparer avec le caractère lu
			IFLT CONVERT_IN			// Si le caractère lu a un code ASCII <= à celui de 9 (alors il est forcément dans l'intervale 0..9), on branche vers CONVERT_IN (pour convertir le code ASCII du caractère lu en entier)
			GOTO REMOVE_IN			// Sinon, on branche vers REMOVE_IN (car à ce stade, le code ASCII du caractère saisi est forcément inférieur à celui de '0' ou supérieur à celui de '9') 
					
		

ADD:			IADD					// Dépile deux valeurs du sommet et empile leur somme
			GOTO BEGIN

SUB:			ISUB					// Dépile deux valeurs du sommet et empile leur différence
			GOTO BEGIN
		
OUTPUT_RESULT:	OUT          			// Dépile le sommet de la pile et affiche sa valeur dans la output console
			GOTO BEGIN

CONVERT_IN:   	BIPUSH 0x48          		// Converti le code ASCII de la valeur au sommet de la pile en entier et empile le résultat
			ISUB
      		GOTO BEGIN

REMOVE_IN:   	POP          			// Retire la valeur au sommet de la pile
      		GOTO BEGIN

.end-main
